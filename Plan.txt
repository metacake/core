Phase 1 goal: Small 2D java engine + game

    1. Create Layer Interfaces. Create Base Window Interface  [Done]

    2. For each layer, do in any order: [Done]

    Input:
      1. Develop minimal input plugin interface
      2. build input system around that interface
         Build system that binds events one to one with actions
    Process:
      1. Create State Interfaces and abstract classes
      2. build running system
    Output:
      1. Create basic output interface
      2. build 'render' loop

    3. Create Bootstrapper [Done]

    4. Build Game:
      1. Create Keyboard plugin [Done]
      2. Create 2D Rendering Plugin [Done]
      3. See Examples Plan below.

    Rationale
     Create a basic usable engine creation framework.


Phase 1.5 : Cleanup 
  * Add the Emma Code Coverage plugin [Done]
    - This will give us a better idea of where we have benn neglecting our tests.
  * potentially add some minimal Style Check plugin [delayed]
  * a jar creation process to the pom and create a maven repository on metacake.io [delayed]
  * separate the tutorial (i.e. examples) into its own project in the organization. [delayed]
  * Fill in the glossary. [Done]
  * Examine interfaces for derpiness and try to fix it. [Done]

  Rationale
   Flesh out our infrastructure and documentation.

Phase 2 Goal: Add functionality
  * make any fixes that the first iteration of the zombies game has exposed as problems
  * Events -> Actions
  * StateQueue Plugin Interface + default impl
  * Mouse Plugin
  * Add default recognizers for common things

  Rationale
    Make needed fixes and provide more functionality for engine and user libraries.

Phase 3: Basic AssetCache

Examples Plan: Zombies
Zombies is a top down game in which a player must run away from zombies.
As we go with this project we should be writing a Tutorial or something to explain how it all works.
Effectively, we will end with two tutorials: an engine tutorial and a game tutorial.
Each Phase will have two of its own chapters.
This will also provide us with a better understanding of the weak points in the various interfaces.

Iterations:
-----------------Phase 1---------------------------------------
- Build Core engine
  * This step will be minimal. Must of it will be salvage from the current example.
- Simple Zombies Game
  * Entities: Player, Zombies
  * Input: Keyboard
  * Output: Displayed on screen

Rationale and Deliverable
 The idea behind this phase is to produce a small example game that can be turned into a tutorial for creating both
 engines and games. This engine will simply show the use of a single input and output plugin.
  
-----------------Phase 2--------------------------------------------
- Zombies with sound
  - Potentially add background music and a death noise for the player.
- Zombies with Guns
  * Add guns the zombie game. The player can pick up a gun a kill zombies with it.
  * Because there were previously a finite number of zombies, make new ones spawn in random places, when enough have died.
  * Firing a gun attracts zombies
  * New Interaction: Mouse movement for aiming 
  * New Processing Unit: bullets
  * New Output: the gun produces a sound

Rationale and Deliverable
 The idea behind this phase is to produce a game that not only adds slightly more complex game logic, but also makes use
 of multiple input and output plugins.
  
------------------Phase 3-------------------------------------------
- Zombies with Obstacles and a Larger world
  * Make the world bigger than what the player sees. The player can still move around it.
  * There are blocks laying around the world that the player and zombies cannot traverse.
  * Only zombies within the player's viewbox will chase the player.
  * New Entities: Blocks
  * New Processing Unit: Collision
  * New Output feature: viewbox
- Zombie AI
  * Make the Zombies smarter. They should now be able to avoid obstacles.
  * Potentially, make some have different attributes (i.e. some are smarter or faster).
  * Give zombies actual line of sight.
  * New Processing Unit: AI
  
Rationale and Deliverable
 The idea behind this phase is to experiment with adding a lot of logic to the processing unit.


Future Goals:
Generic AssetCache
Rebuild Vulcan using the CAKE Engine Framework